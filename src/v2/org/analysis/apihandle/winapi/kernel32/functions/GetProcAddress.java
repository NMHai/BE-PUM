/**
 * Project: BE_PUM_V1
 * Package name: org.be_pum.winapi.kernel32.functions
 * File name: GetProcAddress.java
 * Created date: Feb 2, 2015
 * Description:
 */
package v2.org.analysis.apihandle.winapi.kernel32.functions;

import org.jakstab.Program;
import org.jakstab.asm.AbsoluteAddress;

import v2.org.analysis.apihandle.winapi.APIHandle;
import v2.org.analysis.apihandle.winapi.kernel32.Kernel32API;
import v2.org.analysis.apihandle.winapi.kernel32.Kernel32DLLwithoutOption;
import v2.org.analysis.util.PairEntry;
import v2.org.analysis.value.LongValue;

import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.WinDef.HMODULE;

/**
 * @author Yen Nguyen
 *
 */
public class GetProcAddress extends Kernel32API {
	private long mProcInputValue = 0;

	public GetProcAddress() {
		super();
		NUM_OF_PARMS = 2;
	}

	@Override
	public void execute() {
		/*
		 * returnValue = APIHandler.getProcAddress( ((ValueLongExp)
		 * x1).getValue(), ((ValueLongExp) x2).getValue(), program);
		 */
		long t1 = this.params.get(0);
		long t2 = this.params.get(1);		
		
		String lpProcName = memory.getText(this, t2);
		this.mProcInputValue = t2;
		
		if (lpProcName == null || 
				lpProcName.length() == 0 || lpProcName == "") {
			System.out.println("Get ProcAddres from Ordinal Number!");
			String libName = curState.getEnvironement().getSystem().getLibraryName(t1);
			lpProcName = Program.getProgram().getNameFromOrdinalNumber(libName, t2);
		}

		long ret = this.execute(t1, lpProcName);

		register.mov("eax", new LongValue(ret));
	}

	public long execute(long libHandle, String procName) {
		PairEntry<String, Integer> libEntry = APIHandle.libraryHandleMap.get(libHandle);
		long ret = 0;
		
		if (procName == null || procName == "") {
			return 0;
		}

		System.out.println("Function Name:" + procName + ", Library Handle:0x" + Long.toHexString(libHandle));

		// This handle had been enrolled in the system by JNA
		if (libEntry.getValue() == -1) {
			HMODULE hModule = new HMODULE();
			hModule.setPointer(new Pointer(libHandle));

			if (procName.isEmpty() && Program.getProgram() != null
					&& !Program.getProgram().isInside(new AbsoluteAddress(this.mProcInputValue))) {
				ret = Kernel32DLLwithoutOption.INSTANCE.GetProcAddress(hModule, new Pointer(this.mProcInputValue));
			} else {
				ret = Kernel32DLLwithoutOption.INSTANCE.GetProcAddress(hModule, procName);
			}
		} else {
			// If this handle is not generated by simulator
			int temp = libEntry.getValue().intValue() + 1;
			libEntry.setValue(temp);
			ret = (libHandle + temp);
		}

		if (ret != 0) {
			APIHandle.procAddressHandleMap.put(ret, procName + '@' + libEntry.getKey());
		}

		return ret;
	}
}
