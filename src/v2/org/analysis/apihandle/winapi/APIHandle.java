package v2.org.analysis.apihandle.winapi;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jakstab.Program;
import org.jakstab.asm.AbsoluteAddress;
import org.jakstab.asm.Instruction;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.sun.jna.platform.win32.Kernel32;

import v2.org.analysis.cfg.BPCFG;
import v2.org.analysis.cfg.BPEdge;
import v2.org.analysis.cfg.BPVertex;
import v2.org.analysis.environment.Environment;
import v2.org.analysis.environment.stack.Stack;
import v2.org.analysis.packer.PackerConstants;
import v2.org.analysis.packer.PackerManager;
import v2.org.analysis.packer.techniques.TwoSpecialAPIs;
import v2.org.analysis.path.BPPath;
import v2.org.analysis.path.BPState;
import v2.org.analysis.statistics.FileProcess;
import v2.org.analysis.system.VirtualMem;
import v2.org.analysis.transition_rule.X86TransitionRule;
import v2.org.analysis.util.PairEntry;
import v2.org.analysis.value.LongValue;
import v2.org.analysis.value.SymbolValue;
import v2.org.analysis.value.Value;

//import v2.org.analysis.apihandle.be_pum.winapi.kernel32.Kernel32Stub;

public class APIHandle {
	public static final int BASE_LIB_HANDLE = 0x88880000;
	private static final String UNSUPPORT_API_PATH = "data/data/unsupportAPI.txt";
	private static final String MISSING_API_PATH = "data/data/missingAPI.txt";

	private static HashMap<String, HashMap<String, String>> apiMapping = new HashMap<>();
	private static Map<String, Integer> unsupportAPIMapping = null;
	private static List<String> missingAPIList = null;
	/**
	 * This map contains all the handleValue and the its pairEntry (library name &
	 * number of process address generated by emulator (positive) or -1 if the handleValue
	 * is enrolled by JNA).
	 */
	public static Map<Long, PairEntry<String, Integer>> libraryHandleMap = new HashMap<>();
	public static Map<Long, String> procAddressHandleMap = new HashMap<>();
	public static boolean isDebug = true;
	private static long addrNewOperator = 0x363c68;	
	private static int numAPI = 0;

	static {
		try {
			String directory = APIHandle.class.getPackage().getName().replace(".", "/");
			String fileName = "/" + directory + "/APIMap.json";

			final Type MAP_TYPE = new TypeToken<HashMap<String, HashMap<String, String>>>() {
			}.getType();
			Gson gson = new Gson();
			JsonReader reader = new JsonReader(new InputStreamReader(APIHandle.class.getResourceAsStream(fileName), "UTF-8"));
			apiMapping = gson.fromJson(reader, MAP_TYPE);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static String findClassName(String funcName, String dllName) {
		if (funcName == null) {
			return null;
		}

		String fullClassName = null;
		HashMap<String, String> map = null;

		if ((map = apiMapping.get(dllName)) != null) {
			fullClassName = map.get(funcName);
			if (fullClassName == null) {
				char lastChar = funcName.charAt(funcName.length() - 1);
				if (lastChar == 'a' || lastChar == 'w') {
					funcName = funcName.substring(0, funcName.length() - 1);
					fullClassName = map.get(funcName);
				}
			}
		}
		return fullClassName;
	}
	
	public static void executeAPI(AbsoluteAddress address, String api, Instruction inst, BPPath path,
			List<BPPath> pathList) {
		numAPI ++; 
		if (numAPI < 4) {
			String name = api.toLowerCase();
			for (String twoSpecialName: PackerConstants.TWOSPECIAL_APIs_Main) {
				if (name.contains(twoSpecialName.toLowerCase())) {
					((TwoSpecialAPIs)PackerManager.getInstance().getTechniques().getTechnique(PackerConstants.TWO_APIS)).setFirstCall(true);;
					break;
				}
			}			
		}
		
		System.out.println("\n\tCall api: " + api);		
		String apiNameAttributes[] = api.split("@");
		
		String funcName = apiNameAttributes[0];
		String dllName = (apiNameAttributes.length > 1 && apiNameAttributes[1] != null)
						? apiNameAttributes[1].split("\\.")[0]
						: null;
		
		BPState curState = path.getCurrentState();
		Environment env = curState.getEnvironement();
		Stack stack = env.getStack();
		// Memory memory = env.getMemory();
		// Register register = env.getRegister();
		Program program = Program.getProgram();
		// SystemHandle system = env.getSystem();
		BPCFG cfg = program.getBPCFG();

		System.out.println("\tIns address of api: " + curState.getLocation());		
		System.out.println("Register: " + curState.getEnvironement().getRegister().toString());
		System.out.println("Flag: " + curState.getEnvironement().getFlag().toString());
		PackerManager.getInstance().checkAPIName(api, curState.getLocation().getValue());
		if (inst.getName().toString().equals("jmp")) {
			System.out.println("JMP API:" + funcName);

			BPVertex v1 = cfg.getVertex(curState.getLocation(), curState.getInstruction());
			v1.setProperty(api);
			BPVertex v2 = new BPVertex();
			// v2.setAddress(address);
			v2.setProperty(api);

			if (funcName.equals("ExitProcess") || funcName.equals("exit")) {
				v2.setType(BPVertex.ExitNode);
				v2 = cfg.insertVertex(v2);
				// v2.setProperty(api);
				cfg.insertEdge(new BPEdge(v1, v2));
				curState.setLocation(null);
				curState.setInstruction(null);
				return;
			} else if (funcName.equals("RaiseException")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				Value x4 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4);
				
				curState = new X86TransitionRule().processSEH(curState);
				return;
			}

			v2.setType(BPVertex.APINode);
			v2 = cfg.insertVertex(v2);
			cfg.insertEdge(new BPEdge(v1, v2));
			Value returnAddr = stack.pop();
			long r = 0;
			if (// path.getPreviousInst() instanceof X86CallInstruction &&
			returnAddr != null && returnAddr instanceof LongValue) {
				r = ((LongValue) returnAddr).getValue();
			} else {
				r = curState.getLocation().getValue() + curState.getInstruction().getSize();
				stack.push(returnAddr);
			}
			AbsoluteAddress addr = new AbsoluteAddress(r);
			Instruction newInst = program.getInstruction(addr, env);
			v1 = cfg.insertVertex(new BPVertex(addr, newInst));
			cfg.insertEdge(new BPEdge(v2, v1));

			curState.setLocation(addr);
			curState.setInstruction(newInst);
		} else if (inst.getName().toString().equals("call")) {
			System.out.println("Call API:" + funcName);

			BPVertex v1 = cfg.getVertex(curState.getLocation(), curState.getInstruction());
			v1.setProperty(api);
			BPVertex v2 = new BPVertex();
			// v2.setAddress(address);
			v2.setProperty(api);

			if (funcName.equals("ExitProcess") || funcName.equals("exit")) {
				v2.setType(BPVertex.ExitNode);
				v2 = cfg.insertVertex(v2);
				// v2.setProperty(api);
				cfg.insertEdge(new BPEdge(v1, v2));
				curState.setLocation(null);
				curState.setInstruction(null);
				return;
			} else if (funcName.equals("RaiseException")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				Value x4 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4);
				
				curState = new X86TransitionRule().processSEH(curState);
				return;
			}

			v2.setType(BPVertex.APINode);
			v2 = cfg.insertVertex(v2);
			cfg.insertEdge(new BPEdge(v1, v2));

			long r = curState.getLocation().getValue() + curState.getInstruction().getSize();
			AbsoluteAddress addr = new AbsoluteAddress(r);
			// PHONG: change here for virtual memory
			Instruction newInst;
			if (curState.getEnvironement().getSystem().isInVirtualMemory() == true) {
				byte[] opcodes = getOpcodesArray(curState, addr.getValue());
				// NEXT INSTRUCTION FOR CALL
				newInst = Program.getProgram().getInstruction(opcodes, env);
			} else {
				newInst = program.getInstruction(addr, env);
			}

			v1 = cfg.insertVertex(new BPVertex(addr, newInst));
			cfg.insertEdge(new BPEdge(v2, v1));

			curState.setLocation(addr);
			curState.setInstruction(newInst);
		} else if (inst.getName().toString().contains("ret")) {
			System.out.println("RET API:" + funcName);

			BPVertex v1 = cfg.getVertex(curState.getLocation(), curState.getInstruction());
			v1.setProperty(api);
			BPVertex v2 = new BPVertex();
			// v2.setAddress(address);
			v2.setProperty(api);

			if (funcName.equals("ExitProcess") || funcName.equals("exit")) {
				v2.setType(BPVertex.ExitNode);
				v2 = cfg.insertVertex(v2);
				// v2.setProperty(api);
				cfg.insertEdge(new BPEdge(v1, v2));
				curState.setLocation(null);
				curState.setInstruction(null);
				return;
			}

			v2.setType(BPVertex.APINode);
			v2 = cfg.insertVertex(v2);
			cfg.insertEdge(new BPEdge(v1, v2));

			Value ret = env.getStack().pop();
			long r = 0;
			if (ret != null && ret instanceof LongValue) {
				r = ((LongValue) ret).getValue();
			}
			AbsoluteAddress addr = new AbsoluteAddress(r);
			// PHONG: change here for virtual memory
			Instruction newInst;
			if (curState.getEnvironement().getSystem().isInVirtualMemory() == true) {
				byte[] opcodes = getOpcodesArray(curState, addr.getValue());
				// NEXT INSTRUCTION FOR CALL
				newInst = Program.getProgram().getInstruction(opcodes, env);
			} else {
				newInst = program.getInstruction(addr, env);
			}

			v1 = cfg.insertVertex(new BPVertex(addr, newInst));
			cfg.insertEdge(new BPEdge(v2, v1));

			curState.setLocation(addr);
			curState.setInstruction(newInst);
		}



		/**********************************************
		 * Special API that I hadn't found the define *
		 **********************************************/
		if (apiNameAttributes[0].equals("") || apiNameAttributes[0] == null) {
			System.out.println("\tName of API is null");
			return;
		}
			
		
		if (apiNameAttributes[0].toLowerCase().startsWith("ord(")) {
			System.out.println("\t\tCAN NOT FIND API DEFINE");
			Value x = stack.pop();
			System.out.println("Argument: " + x);
			env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			return;
		}

		String className = findClassName(funcName.toLowerCase(), dllName.toLowerCase());

		/*
		 * // PHONG - 20150728 /////////////////////////////////////// if
		 * (t[0].contains("LoadLibraryA"))
		 * Program.getProgram().setTechnique("UseAPI: LoadLibrary"); if
		 * (t[0].contains("GetProcAddress"))
		 * Program.getProgram().setTechnique("UseAPI: GetProcAddress"); if
		 * (t[0].contains("VirtualAlloc"))
		 * Program.getProgram().setTechnique("UseAPI: VirtualAlloc"); if
		 * (t[0].contains("IsDebuggerPresent"))
		 * Program.getProgram().setTechnique("UseAPI: IsDebuggerPresent"); //
		 * ////////////////////////////////////////////////////////
		 */
		if (className != null) {
			try {
				Class<?> clazz = Class.forName(className);
				Constructor<?> ctor = clazz.getConstructor();
				API apiObject = (API) ctor.newInstance();
				apiObject.run(address, path.getCurrentState(), inst, apiNameAttributes[0]);
				
				System.out.println("\tLast Error: " + Kernel32.INSTANCE.GetLastError());
			} catch (APIException ex) {
				ex.writeLog();
				ex.printStackTrace();
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else {
			System.out.println("Unsupported API: " + api);
			
			if (unsupportAPIMapping == null) {
				unsupportAPIMapping = readAPI();
			}
			
			if (missingAPIList == null) {
				missingAPIList = new ArrayList<>();
			}
			
			for (Map.Entry<String, Integer> entry: unsupportAPIMapping.entrySet()) {
				if (funcName.startsWith(entry.getKey()) || entry.getKey().startsWith(funcName)) {
					int num = entry.getValue();
					System.out.print("Argument: ");
					for (int i=0; i<num; i++) {
						Value x = stack.pop();
						System.out.print(x + ", ");
					}
					System.out.println();
					env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
					System.out.println("EAX=" + env.getRegister().getRegisterValue("eax"));
					return;
				}
			}
			
			if (!missingAPIList.contains(api)) {
				new FileProcess(MISSING_API_PATH).appendFile(Program.getProgram().getFileName() + "\t" + api);
				missingAPIList.add(api);
			}
			
			if (api.startsWith("??2@YAPAXI@Z")) {				
				Value sizeVal = curState.getEnvironement().getStack().pop();
				System.out.println("Size:" + sizeVal.toString());
				if (sizeVal != null && sizeVal instanceof LongValue) {
					long addr = addrNewOperator;
					long size = ((LongValue)sizeVal).getValue();
					curState.getEnvironement().getMemory().createMemory(addr, size);
					
					env.getRegister().setRegisterValue("eax", new LongValue(addr));
					addrNewOperator = addr + size + 28;
				} else {
					env.getRegister().setRegisterValue("eax", new SymbolValue("eax_YAPAXI"));
				}
				
				// This API does not pop out
				
												
				
				curState.getEnvironement().getStack().push(sizeVal);;
				System.out.println("EAX=" + env.getRegister().getRegisterValue("eax"));
				
				return;
			} else if (funcName.startsWith("InternetGetConnectedState")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("s_perror")) { // Can not find
															// definition
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("setusermatherr")) { // Can not find
																// definition
				Value x1 = stack.pop();
				System.out.println("Argument: " + x1);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("puts")) { // Just for print in
														// console, what DLL
														// file is this API
														// belong to?
				Value x1 = stack.pop();
				System.out.println("Argument: " + x1);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("_write")) { // DLL???
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				System.out.println("Argument= " + x1 + ", " + x2 + ", " + x3);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("ord(115)")) { // ?????????
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				System.out.println("WSAStarup API: Argument= " + x1 + ", " + x2);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("_initterm")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("__getmainargs")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				Value x4 = stack.pop();
				Value x5 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4 + ", " + x5);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("_controlfp")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				stack.push(x2);
				stack.push(x1);
				System.out.println("Argument: " + x1 + ", " + x2);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("__set_app_type")) {
				Value x1 = stack.pop();
				System.out.println("Argument: " + x1);
				env.getRegister().setRegisterValue("eax", new LongValue(1));
			} else if (funcName.startsWith("_hread")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();

				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("_hwrite")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();

				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("SendNotifyMessageA")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				Value x4 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} 
			else if (funcName.startsWith("PStoreCreateInstance")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				Value x4 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else if (funcName.startsWith("RaiseException")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				Value x3 = stack.pop();
				Value x4 = stack.pop();
				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} 
			else if (funcName.startsWith("EnumWindows")) {
				Value x1 = stack.pop();
				Value x2 = stack.pop();
				
				System.out.println("Argument: " + x1 + ", " + x2);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} 
//			else if (funcName.startsWith("CoCreateInstance")) {
//				Value x1 = stack.pop();
//				Value x2 = stack.pop();
//				Value x3 = stack.pop();
//				Value x4 = stack.pop();
//				Value x5 = stack.pop();
//				
//				System.out.println("Argument: " + x1 + ", " + x2 + ", " + x3 + ", " + x4 + ", " + x5);
//				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
//			} 
			else if (funcName.startsWith("InitializeSListHead")) {
				Value x1 = stack.pop();
				System.out.println("Argument: " + x1);
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax_" + funcName));
			} else {
				System.out.println("No Handling of this API");
				env.getRegister().setRegisterValue("eax", new SymbolValue("api_eax"));
			}
		}

		System.out.println("EAX=" + env.getRegister().getRegisterValue("eax"));
	}

	private static Map<String, Integer> readAPI() {
		Map<String, Integer> t = new HashMap<> ();
		try {
			// clearContentFile(unprocessedFile);
			BufferedReader br = new BufferedReader(new FileReader(UNSUPPORT_API_PATH));
			// StringBuilder sb = new StringBuilder();			
			String line = br.readLine();
			while (line != null) {
				// numFile++;
				// sb.append(line);
				// sb.append('\n');
				// if (!readInstFile(pathResult, line))
				// numUnprocessedFile++;
				String temp[] = line.split(" ");
				if (temp.length > 1) {
					t.put(temp[0], Integer.parseInt(temp[1]));
				}
				line = br.readLine();
				// if (numFile > 0) break;
			}
			br.close();
		} catch (Exception e) {
			System.out.println(e.toString());
		}
		
		return t;
	}

	// PHONG: insert here
	// Need to improve here, process the opcodes[] for best performance
	public static byte[] getOpcodesArray(BPState curState, long address) {
		VirtualMem vM = curState.getEnvironement().getSystem().getVirtualHandle().getCurrentVirtualMemory();
		vM.setAddress(address);
		// long offset = address - vM.getBaseAddress();
		byte[] opcodes = new byte[(int) vM.getSize()];
		// can modify here for best result, i < 10, because one asm statement
		// needs 10 bytes or less
		for (int i = 0; i < /* vM.getSize() - offset */10; i++) {
			long virtualAdrr = vM.getAddress() + i;
			opcodes[i] = (byte) ((LongValue) curState.getEnvironement().getMemory().getByteMemoryValue(virtualAdrr))
					.getValue();
		}
		return opcodes;
	}

	public static String getAPINameFromAddress(long address) {
		String api = APIHandle.procAddressHandleMap.get(address);
		return api;
	}

	public static String getLibName(long libraryHandle) {
		if (libraryHandleMap.containsKey(libraryHandle)) {
			return libraryHandleMap.get(libraryHandle).getKey();
		}
		
		return "";
	}

	public static long generateRandomNumber(int count) {
		return (long) (APIHandle.BASE_LIB_HANDLE + (Math.random() * 0xFFFF * count));
	}
	
	public static long generateRandomNumber(long base, int count) {
		return (long) (base + (Math.random() * 0xDDDD * count));
	}
}
